# Implement Azure Security (10-15%)

## Implement Authentication

### Implement Authentication by using certificates, forms-based authentication, or tokens
_Authentication_ validates a users identity.  Users authenticate with some form of credentials.  An authenticated identity can then be _authorized_ to access specific resources.  An _authenticated user_ is an identity that has successfully passed an authentication check using some form of credentials.  An _authenticate provider_ or _identity provider_, is a service that manages the authentication of a user with a set of stored credential information.  Azure App Service currently supports five authentication providers.  Azure AD, Microsoft Account, Facebook, Google, Twitter.

_Authentication endpoints_ are specific app URIs for handling sign-in, sign-out, and other authentication operations.  These endpoints can be called by your web app to initiate authentiation process, and to verify user identities while the app is being used.  

An _authentiation token_ is generated by the authentication provider, and may include information on the user's authentication status and a list of resources that the user may access.

Depending on whether you are doing everything within the browser, the authentication flow may differ slightly; for example, the authentication flow may vary between Javascript and a provider SDK for a language framework such as .Net.  

Browser: 
1) _Not Authenticated_: User tries to access web app, but it not yet signed in.
2) _User sign-in_: Client is redirected to the federated Microsoft login page at: */.auth/login/[provider]*.
3) _Post authentication_: The provider redirects the client to /.auth/login/[provider]/callback.
4) _Establish autheticated session_: The Azure App Service adds an authenticated cookie to response back to the client;  this is the AppServiceAuthSession cookie.
5) _Deliver authenticated content_: The client includes the authentication cookie in subsequent requests. (handled by the browser).

OPTIONAL

6) _Obtain access token_:   Use Javascript in your web app to call the /.auth/me endpoint to get an access token; your app can use this token to access resources managed by Express, Graph, and other APIs.
7) _Refresh Token_:  If the access token expires, use JavaScript in your app to call the /.auth/refresh endpoing, and then to call the /.auth/me endpoint to obtain the refreshed token.
8) _Sign out_: Provide a sign-out option in your app, by providing a link to the /.auth/logout endpoint.

SDK:
1) _User sign-in_: Client code is issued to sign-in the user with the provider's SDK, and the user's browser receives an authentication token.
2) _Post authentication_: Client code sends the authentication token to /.auth/login/[provider] for validation
3) _Establish authenticated session_: The Azure App Service returns its own authentication token to client code.
4) _Deliver authenticated content_: Client code sends this authentication token with the *X-ZUMO_AUTH* header.  (handled by client SDK or mobile app)

At the App Service level, you configure the way your apps will handle authentication.

1) App Service Authentication (OFF) : Default setting, authentication and authorization are not managed by the Azure App Service, and all client requests are allowed.  Can still write authentication and authorization code.

2) App Service Authentication (ON) : You can now set the default action if your app receives an unauthenticated client request by using the _Action to take when request is not authenticated_ setting:

a) Allow Anonymous Requests (no action) : all requests are allowed.  If client has not been authenticated, use app code to control what happens next; i.e. redirection to the sign-on endpoint.

b) Sign in with [provider] : The Azure App Service redirects all anonymous requests to */.auth/login/[provider] for the provider you chose.  Only authenticated requests are allowed.  You don't need to write any additional code.

For Microsoft Account authentication, the App Registration Portal is used to generate the Client ID and Client Secret.  These are referred to as Application ID and Password in the portal.

The Microsoft and Facebook providers also support configurable scopes, so you can choose how much user information your app can request to access;

If you want your users to be able to sign out of your application, you'll need to enable your app to send a GET request to the app's /.auth/logout endpoint.  After this request is sent: (1) authentication cookies will be cleared from the session. (2) The current user's tokens will be deleted from the token store.  (3) For Azure Active Directory and google, a server-side sign-out is initiated on the identity provider.  

A Redirect Url is used to control your app's authentication and post-authentication behavior.  For example, after a successful sign-in, you typically want to ensure that your users are redirected to your app's default page.  Similarly, if you provide a Sign-out link, you might want to redirect signed out users back to your app's sign-in page, to give users the option to sign-in again.  For Microsoft Account authentication, The App Registration Portal is used to register redirect Urls.

The Azure Portal doesn't have an option for supporting multiple providers, so you need to first configure each identity provider you want to enable, then in the Action to take when request is not authenticated_ setting, select Allow Anonymous requests (no action).  

An authentication or seurity token is a method for authenticating user requests to access resources.  After authenticating to an identity service, a token is generated, and this token is then presented to any secure resource that th euser wants to access.  The token may also include information on resources that the user may access.

The security tokens used by the Azure App Service are in JSON Web Token (JWT) format.  JWT is an open standard, and is used to create tokens that assert one or more claims.  i.e. if you are a web server administrator, when you authenticate to the server, a token might be generated that inlcudes a claim _authenticated as server admin_.  Your browser, or other client, then presents this token whenever it needs to assert or prove that is has admin authority.  JWT tokens are signed with a private key.  

The app service has distinct tokens for user Id (ID Token), asserting access permissions (access token), and after a token has expired then been refreshed (refresh token).

An Azure App Service includes a token store, which can be used to hold tokens associated with your web app users.  This store is enabled by default when you enable authentication with any provider.  In order to use tokens in your web app, your app needs to be able to retrieve, store, and refresh tokens.  

Claims and Headers
In your web app, you might want to make use of the user claims within a token, such as authenticated as admin, user principal name, or user email address.  One way to achieve this is through the HTTP request headers.  For all supported language frameworks, the Azure App Service makes these claims available to your code by injecting them into the request headers.  i.e. *X-MS-CLIENT_PRINCIPAL-NAME, X-MS-CLIENT-PRINCIPAL-ID*.

You can view the available claims by using a web browser, and going to your app's /.auth/me endpoint.  You should be able to see various elements of the token, including: access_token, expires_on, provider_name, user_claims, user_id.  If you expand the user_claims, you'll see a list of claims that have been returned i.e. nameidentifier, name, givenname, surname, microsoft account: locale, microsoft account:ID, microsoft account: name.  For browser apps you can also check for the existence of an AppServiceAuthSession cookie.  

### Implement multi-factor or Windows authentication using Azure AD
Digital identities are an integral part of today's business and social interactions on-premises and online.  The prior way of identity management was able to be controlled through on-prem solutions such as Kerberos or LDAP.

With single-sign-on, users only need to remember one ID and one password.  Access across applications is granted to a single identity tied to a user, simplifying the security model.  As users change roles or leave an organization, access modifications are tied to a single identity, greatly reducing the effort needed to change or disable accounts.  

Azure Active Directory (AD) is a cloud-based identity service.  It has built-in support for synchronizing with your existing on-premises Active Directory or can be used standalone.   

Azure AD Connect will integrate your on-premises directories with Azure Active Directory.  Azure AD Connect provides the newest capabilities and replaces older versions of identity integration tools such as DirSync and Azure AD Sync.  

Multi-factor Authentication (MFA) provides additional security for your identities by requiring two or more elements for full authentication.  These elements fall into (3) categories
1) something you know : i.e. a password
2) something you possess: i.e. a mobile app or token
3) something you are: i.e. biometrics

Using MFA increases security by providing an extra buffer if one of your security credentials are compromised.  Azure AD has MFA capabilities built-in, and will integrate with any other third-party MFA providers.  It's provided to Global Administrators role in AD.

Azure AD provides a conditional access policies (CAP) feature that includes support for access policies baesd on group, location, or device state.  An example of this is requiring users outside of the ip address range for the local network to authenticate with MFA before being given access.  

Azure AD Application Proxy can quickly, easily, and securely allow applications to be accessed remotely without changing their legacy authentication method.  It's composed of two components: a connector agent that sits on a Windows server within your corporate network and an external endpoint, either the MyApps portal or an external Url.  

Azure AD B2C is an identity management service built on the solid foundations of Azure Active Directory that enables you to customize and control how customers sign up, sign in, and manage their profiles when using your applications. 

### Implement OAuth2 authentication 

### Implement Managed Service Identity (MSI) / Service Principal Authentication

## Implement Access Control

### Implement CBAC (Claims-Based Access Control) authorization

### Implement RBAC (Role-Based Access Control) authorization
Role-based access control (RBAC) defines user access through a set of rules.  Roles are defined as collections of access permissions.  Security principals are mapped to roles directly or through group membership.  In Azure, users, groups, and roles are stored in Azure Active Directory (AD).  The Azure Resource Manager API uses role-based access control to secure all resource access management in AZure.  RBAC is an allow model.

Roles are sets of permissions, like "Read-only" or "Contributor", that users can be granted to access an Azure service instance.  Roles can be granted at the individual service instance level, but they also flow down the Azure Resource Manager hierarchy.  Roles assigned at a higher scope, like an entire subscription, are inherited by child scopes, like service instance.

To create a role assignment you need (3) elements: (1) a security principal, (2) a role definition, (3) a scope.  This is the who, what, and where elements.

Management groups are an additional hierarchical level recently introduced into the RBAC model.  They allow the abilty to group subscriptions together, and apply policy at an even higher level.

Azure AD Privileged Identity Management (PIM) is an additional paid-for offering that provides oversight of role assignments, self service, and just-in-time role activation.

An identity is just a thing that can be authenticated.  An account is data associated with an identity.  A principal is an identity acting with certain roles or claims.  i.e. running as administrator.  A Service Principal is an identity that is used by a service or application.  It can be assigned roles just like individuals can.  

A managed identity for an app can be instantly crated for any Azure service that supports it.  When you create a managed identity for a service, you are creating an account on the Azure AD tenant.  

### Create shared access signatures
A shared access signature (SAS) is a string that contains a security token that can be attached to a Uri.  Use a shared access signature to delegate access to storage objects and specify constraints, such as the permissions and the time range of access.

_service-level_ shared access signatures allow access to specific resources in a storage account.  i.e. allow a resource to download a file.  _account-level_ shared access signatures allow access to anything that a service-level shared access signature can allow, plus additional resources and abilities.  i.e. allowing a user to create a file system.  

Advanced Thread Protection (ATP) in Azure allows users to receive notifications if suspicious activiy is detected on their resources. 

## Implement Secure Data Solutions

### Encrypt and Decrypt data at rest and in transit
Encyrption is the process of making data unreadable and unusable.  To use or read the encrypted data, it must be decrypted, which requires the use of a secret key.  There are two types of encryption:
1) symmetric : uses the same the same key to encrypt and decrypt the data.  
2) asymmetric : asymmetric uses a public and private key pair.  Either key can encrypt but cannot decrypt its own encrypted data.  To decrypt, you need a paired key.

Encryption at rest:  data at rest is the data that has been stored on a physical medium.  i.e. data stored on the disk of a server, data stored in a database, or data stored in a storage account.

Encryption in transit: is data that is actively moving from one location to another.  i.e. over the internet.  _Transport Encryption_ helps protection application data while it's in transit from users to your servers.  Azure Application Gateway is one way that we can encrypt data in transit with Azure.

The first step to protecting data to identify and classify the data based on what type it is.  i.ee personal records  vs public records.  Each industry may have its own data regulation policies.   i.e. HIPAA, GDPR

Azure Storage Service Encryption for data at rest helps you protect your data to meet your organizational and security compliance commitments.  Azure Storage is encrypted with Storage Service Encryption (SSE) with a 256-bit Advanced Encryption Standard (AES) cipher.  

Azure Disk Encryption (ADE) is a capability that helps you encrypt your Windows and Linux IaaS virtual machine disks (VHDs).  ADE leverages the industry standard BitLocker feature of windows and the DM-Crypt feature of Linux.  The solution can be integrated with Azure Key Vault.

Transparent Data Encryption (TDE) helps protect Azure SQL Database and Azure Data Warehouse against the threat of malicious activity.  It performs real-time encryption and decryption for databases, and is enabled for all newly deployed Azure Sql databases.  TDE encrypts the storage of an entire database by using a symmetric key called the database encryption key.  Bring-your-own-key is also supported with Azure Key Vault.

Network Security

Network security can be broken down into layers similarly to how Defense in Depth is broken down into layers.  The first line of defense for the network is perimeter.  Azure Security Center can provide information on which internet-facing resources do not have Network Security Groups (NSGs) assoicated with them.  There are a few way to provide inbound protection: 

_Application Gateway_ is a layer 7 load balancer that also includes a web application firewall (WAF) to provide additional security for HTTP-based services.  The WAF is based on rules from the OWASP 3.0 or 2.2.9 core rule sets.

There are many steps to retrieving/sending encrypted traffic with the Application Gateway:
1) Frontend Port and Listener: Traffic enters the gateway through a front end port.  A listener is the first thing that your traffic meets when entering the gateway through a port.  It's set-up to listen for a specific host name, and specific port on a specific ip address.  The listener can use an ssl certificate to decrypt traffic.  It then forwards traffic to a back-end pool.
2) Backend Pool: The backend pool contains your application servers.  These servers might be virtual machines, a virtual machine scale set, or applications running on Azure App service.  Incoming requests are load balanced across the pool, and recrypts the traffic before forwarding it to pool.


_Network Virtual Appliances_ can be used to protect non-http based services.  NVAs are similar to firewall appliances found on on-prem networks, and are available from most popular security vendors. 

_Azure DDoS Protection_ provides basic protection across all Azure services and enhanced protection for further customization of your resources.  DDoS protection will block attack traffic and forwards the remaining traffic to its intended destination.  It will also notify the owner through Azure Monitor metrics.

Virtual Networks (VNet) are virtually defined networks that may reside on the same hardware.  Network Security Groups (NSGs) help restrict unnecessary communicatin inside of a VNet.  Using them, you can isolate applications between environments, tiers, and services.  To isolate Azure services to only allow communication from virtual networks, use VNet service endpoints.  

Virtual Private Network (VPN) connections are a common way of establishing secure communication channels between networks.  Connection between Azure VNets and on-premises VPN devices are a great way to provide secure communications between your network and your virtual machines on Azure.

_ExpressRoute_ lets you extend your on-premises networks into the Microsoft cloud over a private connection facilitated by a connectivity provider.   To easily integrate multiple VNets in Azure, VNet peering establishes a direct connection between designated VNets. 


**If you are using Azure App Service to host the backend application, you don't need to install the certificates in Application Gateway to connect to the backend pool.**

You can add an authentication certificate to Application Gateway by using the az network application-gateway auth-cert create command in the Azure CLI.

```powershell
az network application-gateway root-cert create \
      --resource-group <resource group name> \
      --gateway-name <application gateway name> \
      --name <certificate name> \
      --cert-file <path to trusted CA certificate>
```

Application Gateway uses a _rule_ to specify how to direct the messages that it receives on its incoming port to the servers in the backend pool.  If the servers are using SSL, you must configure the rule to indicate.
1) That the servers expect traffic through the HTTPS protocol.
2) Which certificate to use to encrypt the traffic and authenticate the connection to a server.

To define an HTTP setting, you use the az network application-gateway http-settings create command in the Azure CLI.

```powershell
az network application-gateway http-settings create \
    --resource-group <resource group name> \
    --gateway-name <application gateway name> \
    --name <HTTPS settings name> \
    --port 443 \
    --protocol Https \
```

You can set-up the backend pool for the application gateway with the following command:

```powershell
az network application-gateway address-pool create \
  --resource-group [Sandbox resource group] \
  --gateway-name gw-shipping \
  --name ap-backend \
  --servers $privateip
```

You can set the backend pool to use the ssl certificate settings with the following command:

```powershell
export rgID="$(az group show --name [Sandbox resource group] --query id --output tsv)"

az network application-gateway http-settings update \
    --resource-group [Sandbox resource group] \
    --gateway-name gw-shipping \
    --name https-settings \
    --set trustedRootCertificates='[{"id": "'$rgID'/providers/Microsoft.Network/applicationGateways/gw-shipping/trustedRootCertificates/shipping-root-cert"}]'s
```

You can create the frontend port with the following command:

```powershell
az network application-gateway frontend-port create \
    --resource-group <resource group name> \
    --gateway-name <application gateway name>  \
    --name <port name>
    --port 443
```

You can create an ssl certificate in the PFX format with the following command:

```powershell
az network application-gateway ssl-cert create \
   --resource-group <resource group name> \
   --gateway-name <application gateway name> \
   --name <ssl certificate name> \
   --cert-file <SSL certificate file (PFX)> \
   --cert-password <password for certificate file>
```

You can then create the listener that receives requests from the frontend port and decrypts them by using this certificate:

```powershell
az network application-gateway http-listener create \
    --resource-group <resource group name> \
    --gateway-name <application gateway name> \
    --name <listener name> \
    --frontend-port <frontend port name> \
    --ssl-cert <ssl certificate name>
```

Finally, you can create a rule which directs messages received through the listener to the servers in the backend pool:

```powershell
az network application-gateway rule create \
    --resource-group <resource group name> \
    --gateway-name <application gateway name> \
    --name <rule name> \
    --address-pool <backend pool> \
    --http-listener <listener name> \
    --http-settings <HTTPS settings name> \
    --rule-type Basic
```

### Create, Read, Update, and Delete keys, secrets, and certificates by using the KeyVault API
Azure Key Vault is a _secret store_: a centralized cloud service for storing application secrets.  Key Vault helps you control your applications' secretes by keeping them in a single central location and providing secure access, permissions control, and access logging.

Secret access and vault management is accomplished through REST Api, which is also supported by all of the Azure management tools as well as client libraries available for many popular languages.  Every vault has a unique URL where its API is hosted.  Azure Key Vault also supports certificates and keys.

**Best practice is to create a vault for each environment of your application (i.e development, test, production).**

Azure Key Vault's API uses Azure Active Directory to authenticate users and applications.  Vault access policies are based on actions, and are applied across an entire vault.  All actions performed on a vault require authentication and authorization - there is no way to grant anonymous access.

To create a key vault in the Cloud Shell, use the following command:

```powershell
az keyvault create \
    --resource-group [resource-group] \
    --name <your-unique-vault-name>
```

To add a secret to the vault, use the following command:

```powershell
az keyvault secret set \
    --name [password-name] \
    --value [password-value] \
    --vault-name <your-unique-vault-name>
```

To start using Azure Key Vault with web applications, we must register the app with Azure Active Directory - this creates an identity for the app.  Apps and users authenticate to Key Vault using an Azure Active Directory authentication token.  Getting a token from Azure Active Directory requires a secret or certificate, because anyone with a token could use the application identity to access all of the secrets in the vault.

_Managed Identities_ for Azure resources is an Azure feature that your app can use to access Key Vault and other Azure services without having to manage even a single secret outside of the vault.  Managed Identities for Azure resources also registers your app in Azure Active Directory, adn will delete the registration if you delete the web app or disable its managed identity.

The official Key Vault client for .Net Core is the KeyVaultClient class in Microsoft.Azure.KeyVault NuGet package.  You can use ASP.Net Core's AddAzureKeyVault method to load all of the secrets from a vault into the Configuration API at startup.

Azure key vault url's use the following format:

```csharp
// Build the current set of configuration to load values from
                    // JSON files and environment variables, including VaultName.
                    var builtConfig = config.Build();

                    // Use VaultName from the configuration to create the full vault URL.
                    var vaultUrl = $"https://{builtConfig["VaultName"]}.vault.azure.net/";

                    // Load all secrets from the vault into configuration. This will automatically
                    // authenticate to the vault using a managed identity. If a managed identity
                    // is not available, it will check if Visual Studio and/or the Azure CLI are
                    // installed locally and see if they are configured with credentials that can
                    // access the vault.
                    config.AddAzureKeyVault(vaultUrl);
```

To add your KeyVault to your webapp, define the VaultName to the configuration

```powershell
az webapp config appsettings set \
    --resource-group [subscription name] \
    --name <your-unique-app-name> \
    --settings 'VaultName=<your-unique-vault-name>'
```

To enable managed identity for your web app, use the following command:

```powershell
az webapp identity assign \
    --resource-group [subscription name] \
    --name <your-unique-app-name>
```

Finally, set the policy for the webapp to use AzureKeyVault with the principalId value copied from the previous step.

```powershell
az keyvault set-policy \
    --secret-permissions get list \
    --name <your-unique-vault-name> \
    --object-id <your-managed-identity-principleid>
```